"""
minimax_agent.py - MiniMax Emulation Layer for Neo-Clone

Provides:
- Intent analysis and classification
- Dynamic skill generation on-demand
- Context-aware reasoning
- MiniMax-style reasoning traces
- Integration with Neo-Clone's brain and logging systems
"""

import re
import json
import time
import inspect
from typing import Dict, Any, List, Optional, Tuple
from pathlib import Path
from datetime import datetime
import hashlib

from skills import BaseSkill


class MiniMaxReasoningTrace:
    """Captures and formats MiniMax-style reasoning traces"""
    
    def __init__(self):
        self.steps = []
        self.start_time = time.time()
        
    def add_step(self, step_name: str, details: str, confidence: float = 1.0):
        """Add a reasoning step with details and confidence"""
        self.steps.append({
            "step": step_name,
            "details": details,
            "confidence": confidence,
            "timestamp": time.time() - self.start_time
        })
        
    def add_intent_analysis(self, text: str, intent: str, confidence: float, keywords: List[str]):
        """Add intent analysis step"""
        self.add_step(
            "Intent Analysis",
            f"Analyzed input '{text[:50]}...' â†’ {intent} (confidence: {confidence:.2f})",
            confidence
        )
        if keywords:
            self.add_step(
                "Keyword Detection",
                f"Found keywords: {', '.join(keywords)}",
                confidence
            )
            
    def add_skill_generation(self, skill_name: str, parameters: Dict[str, Any], code_length: int):
        """Add skill generation step"""
        self.add_step(
            "Dynamic Skill Generation",
            f"Generated skill '{skill_name}' with {len(parameters)} parameters, {code_length} lines of code",
            0.95
        )
        
    def add_context_analysis(self, context: List[str], relevant_items: List[str]):
        """Add context analysis step"""
        self.add_step(
            "Context Analysis",
            f"Analyzed {len(context)} context items, found {len(relevant_items)} relevant",
            0.8
        )
        
    def to_dict(self) -> Dict[str, Any]:
        """Convert trace to dictionary for logging"""
        return {
            "total_time": time.time() - self.start_time,
            "steps": self.steps,
            "step_count": len(self.steps)
        }


class DynamicSkillTemplate:
    """Template for dynamically generated skills"""
    
    SKILL_TEMPLATE = '''from skills import BaseSkill
from typing import Dict, Any

class {class_name}(BaseSkill):
    """
    Dynamically generated skill: {skill_description}
    Generated by MiniMax Agent at {timestamp}
    """
    
    @property
    def name(self) -> str:
        return "{skill_name}"
    
    @property
    def description(self) -> str:
        return "{skill_description}"
    
    @property
    def parameters(self) -> dict:
        return {parameters}
    
    @property
    def example_usage(self) -> str:
        return "{example_usage}"
    
    def execute(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Execute the dynamically generated skill"""
        # Generated implementation
        {implementation}
        
        # Return structured result
        return {{
            "status": "success",
            "skill_name": "{skill_name}",
            "result": result,
            "parameters_used": params,
            "generated_by": "MiniMax Agent",
            "generation_timestamp": "{timestamp}"
        }}
'''

    PLUGIN_TEMPLATE = '''"""
{skill_description}
Auto-generated by MiniMax Agent
"""

from typing import Dict, Any

def main(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Main function for dynamically generated plugin
    """
    {implementation}
    
    return {{
        "status": "success",
        "result": result,
        "generated_by": "MiniMax Agent"
    }}

if __name__ == "__main__":
    # Example usage
    test_params = {test_parameters}
    print(main(test_params))
'''


class MiniMaxAgent(BaseSkill):
    """
    MiniMax Emulation Layer - Provides dynamic reasoning and skill generation
    """
    
    def __init__(self):
        super().__init__()
        self.trace = MiniMaxReasoningTrace()
        self.intent_patterns = {
            "code_generation": [
                r"\b(generate|create|build|make|write)\b.*\b(code|python|script|function|class)\b",
                r"\b(write|create)\b.*\b(api|function|method)\b",
                r"\b(build|make)\b.*\b(tool|utility|helper)\b"
            ],
            "data_analysis": [
                r"\b(analyze|examine|process|transform)\b.*\b(data|file|csv|json)\b",
                r"\b(create|generate)\b.*\b(chart|graph|visualization|plot)\b",
                r"\b(calculate|compute|measure)\b.*\b(statistics|metrics|summary)\b"
            ],
            "web_operations": [
                r"\b(search|find|lookup)\b.*\b(web|internet|online)\b",
                r"\b(fetch|retrieve|download)\b.*\b(file|page|content)\b",
                r"\b(scrape|crawl|extract)\b.*\b(website|data|information)\b"
            ],
            "file_operations": [
                r"\b(read|write|create|delete)\b.*\b(file|directory|folder)\b",
                r"\b(list|show|find)\b.*\b(files|contents)\b",
                r"\b(organize|manage)\b.*\b(files|documents)\b"
            ],
            "skill_creation": [
                r"\b(create|build|generate)\b.*\b(skill|tool|plugin)\b",
                r"\b(make|build)\b.*\b(custom)\b.*\b(function|skill)\b",
                r"\b(design|implement)\b.*\b(new)\b.*\b(feature|capability)\b"
            ]
        }
        
    @property
    def name(self) -> str:
        return "minimax_agent"
    
    @property
    def description(self) -> str:
        return "MiniMax Emulation Layer - Provides dynamic reasoning, intent analysis, and skill generation"
    
    @property
    def parameters(self) -> dict:
        return {
            "mode": {
                "type": "string",
                "description": "Operation mode: 'analyze', 'generate', 'reason'",
                "default": "analyze",
                "choices": ["analyze", "generate", "reason"]
            },
            "context": {
                "type": "list",
                "description": "Additional context for reasoning",
                "default": []
            },
            "detailed_trace": {
                "type": "boolean",
                "description": "Include detailed reasoning trace",
                "default": True
            }
        }
    
    @property
    def example_usage(self) -> str:
        return 'Analyze: "I need to create a Python script to process CSV files"\nGenerate: {"mode": "generate", "skill_name": "csv_processor", "description": "Process CSV files"}\nReason: {"mode": "reason", "query": "best practices for data analysis"}'
    
    def analyze_user_input(self, user_text: str, context: List[str] = None) -> Dict[str, Any]:
        """
        Analyze user input to determine intent and extract actionable information
        """
        self.trace = MiniMaxReasoningTrace()
        context = context or []
        
        # Clean and prepare text
        cleaned_text = user_text.strip().lower()
        words = cleaned_text.split()
        
        # Intent classification
        intent_scores = {}
        matched_keywords = []
        
        for intent, patterns in self.intent_patterns.items():
            score = 0
            intent_keywords = []
            
            for pattern in patterns:
                if re.search(pattern, cleaned_text):
                    score += 1
                    # Extract keywords from pattern
                    pattern_words = re.findall(r'\\b\\w+\\b', pattern)
                    intent_keywords.extend([w for w in words if w in pattern_words])
            
            if score > 0:
                intent_scores[intent] = score / len(patterns)
                matched_keywords.extend(intent_keywords)
        
        # Determine primary intent
        if intent_scores:
            primary_intent = max(intent_scores, key=intent_scores.get)
            confidence = intent_scores[primary_intent]
        else:
            primary_intent = "conversational"
            confidence = 0.1
        
        # Extract entities and actions
        action_words = ["create", "generate", "analyze", "process", "build", "make", "find", "search"]
        detected_actions = [w for w in words if w in action_words]
        
        technology_keywords = [
            "python", "javascript", "api", "csv", "json", "sql", "web", "html", "css",
            "pandas", "numpy", "matplotlib", "requests", "flask", "django"
        ]
        detected_tech = [w for w in words if w in technology_keywords]
        
        # Context analysis
        self.trace.add_context_analysis(context, [c for c in context if any(kw in c.lower() for kw in words)])
        
        # Add intent analysis to trace
        self.trace.add_intent_analysis(
            user_text, 
            primary_intent, 
            confidence, 
            list(set(matched_keywords))
        )
        
        return {
            "primary_intent": primary_intent,
            "confidence": confidence,
            "intent_scores": intent_scores,
            "detected_actions": detected_actions,
            "detected_technologies": detected_tech,
            "matched_keywords": list(set(matched_keywords)),
            "reasoning_trace": self.trace.to_dict(),
            "suggested_skills": self._suggest_skills(primary_intent, detected_tech, detected_actions),
            "complexity_score": self._calculate_complexity(user_text, intent_scores)
        }
    
    def generate_dynamic_skill(self, skill_name: str, description: str, parameters: Dict[str, Any] = None, 
                              context: List[str] = None) -> Dict[str, Any]:
        """
        Generate a dynamic skill based on requirements
        """
        self.trace = MiniMaxReasoningTrace()
        parameters = parameters or {}
        context = context or []
        
        # Analyze requirements
        if not skill_name or not description:
            raise ValueError("Skill name and description are required")
        
        # Sanitize skill name
        safe_skill_name = re.sub(r'[^a-zA-Z0-9_]', '_', skill_name.lower())
        class_name = ''.join(word.capitalize() for word in safe_skill_name.split('_'))
        
        # Generate implementation based on description
        implementation, example_usage = self._generate_implementation(description, context)
        
        # Create skill code
        skill_code = DynamicSkillTemplate.SKILL_TEMPLATE.format(
            class_name=class_name,
            skill_name=safe_skill_name,
            skill_description=description,
            parameters=json.dumps(parameters, indent=4),
            example_usage=example_usage,
            implementation=implementation,
            timestamp=datetime.now().isoformat()
        )
        
        # Add to trace
        self.trace.add_skill_generation(
            safe_skill_name, 
            parameters, 
            len(skill_code.split('\n'))
        )
        
        return {
            "skill_name": safe_skill_name,
            "class_name": class_name,
            "skill_code": skill_code,
            "parameters": parameters,
            "example_usage": example_usage,
            "reasoning_trace": self.trace.to_dict(),
            "generated_at": datetime.now().isoformat(),
            "file_path": f"skills/generated_{safe_skill_name}.py"
        }
    
    def save_generated_skill(self, skill_code: str, file_path: str = None) -> Dict[str, Any]:
        """
        Save generated skill to file system
        """
        if not file_path:
            # Extract skill name from code
            match = re.search(r'return "([a-zA-Z0-9_]+)"', skill_code)
            skill_name = match.group(1) if match else "generated_skill"
            file_path = f"skills/generated_{skill_name}.py"
        
        try:
            skills_dir = Path("skills")
            skills_dir.mkdir(exist_ok=True)
            
            file_path = Path(file_path)
            with open(file_path, 'w') as f:
                f.write(skill_code)
            
            return {
                "status": "success",
                "file_path": str(file_path),
                "message": f"Skill saved successfully to {file_path}"
            }
        except Exception as e:
            return {
                "status": "error",
                "error": str(e),
                "message": "Failed to save skill"
            }
    
    def execute(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """
        Execute MiniMax Agent functionality
        """
        mode = params.get("mode", "analyze")
        user_input = params.get("user_input", "")
        context = params.get("context", [])
        detailed_trace = params.get("detailed_trace", True)
        
        if mode == "analyze":
            if not user_input:
                return {"error": "user_input is required for analysis mode"}
            
            result = self.analyze_user_input(user_input, context)
            result["mode"] = "analyze"
            return result
            
        elif mode == "generate":
            skill_name = params.get("skill_name", "")
            description = params.get("description", "")
            
            if not skill_name or not description:
                return {"error": "skill_name and description are required for generate mode"}
            
            result = self.generate_dynamic_skill(skill_name, description, params.get("parameters", {}), context)
            result["mode"] = "generate"
            return result
            
        elif mode == "reason":
            query = params.get("query", "")
            if not query:
                return {"error": "query is required for reason mode"}
            
            # Provide reasoning for queries
            reasoning = self._generate_reasoning(query, context)
            return {
                "mode": "reason",
                "query": query,
                "reasoning": reasoning,
                "reasoning_trace": self.trace.to_dict() if detailed_trace else None
            }
        
        else:
            return {"error": f"Unknown mode: {mode}"}
    
    def _suggest_skills(self, intent: str, technologies: List[str], actions: List[str]) -> List[str]:
        """Suggest relevant skills based on analysis"""
        suggestions = []
        
        skill_mapping = {
            "code_generation": ["code_generation", "text_analysis"],
            "data_analysis": ["data_inspector", "text_analysis"],
            "web_operations": ["web_search", "text_analysis"],
            "file_operations": ["file_manager", "text_analysis"],
            "skill_creation": ["minimax_agent", "code_generation"]
        }
        
        # Add intent-based suggestions
        suggestions.extend(skill_mapping.get(intent, []))
        
        # Add technology-based suggestions
        if "python" in technologies:
            suggestions.append("code_generation")
        if "csv" in technologies or "json" in technologies:
            suggestions.append("data_inspector")
        if "web" in technologies or "api" in technologies:
            suggestions.append("web_search")
            
        return list(set(suggestions))
    
    def _calculate_complexity(self, text: str, intent_scores: Dict[str, float]) -> float:
        """Calculate complexity score (0-1) for the request"""
        complexity_factors = {
            "length": min(len(text) / 500, 0.3),
            "intent_diversity": min(len(intent_scores) * 0.2, 0.4),
            "technical_terms": sum(1 for word in text.lower().split() if word in [
                "api", "database", "algorithm", "framework", "library", "architecture"
            ]) * 0.1
        }
        
        total_complexity = min(sum(complexity_factors.values()), 1.0)
        return round(total_complexity, 2)
    
    def _generate_implementation(self, description: str, context: List[str]) -> Tuple[str, str]:
        """Generate implementation code based on description"""
        description_lower = description.lower()
        
        # File operations
        if any(word in description_lower for word in ["file", "read", "write", "directory"]):
            implementation = '''# File operations implementation
        import os
        from pathlib import Path
        
        text = params.get("text", "")
        file_path = params.get("file_path", "")
        
        if file_path:
            # Read or write file
            if os.path.exists(file_path):
                with open(file_path, 'r') as f:
                    result = f.read()
            else:
                result = f"File not found: {file_path}"
        else:
            result = text'''
            example_usage = f"process_file with file path and content"
            
        # Data processing
        elif any(word in description_lower for word in ["data", "csv", "json", "process"]):
            implementation = '''# Data processing implementation
        import json
        import csv
        
        data = params.get("data", {})
        
        if isinstance(data, str):
            try:
                data = json.loads(data)
            except:
                result = "Invalid JSON data"
                return {{}}
        
        # Process data
        result = {{
            "processed": True,
            "data_type": type(data).__name__,
            "keys": list(data.keys()) if isinstance(data, dict) else len(data)
        }}'''
            example_usage = f"process_data with JSON/CSV data input"
            
        # Web operations
        elif any(word in description_lower for word in ["web", "api", "http", "request"]):
            implementation = '''# Web operations implementation
        import requests
        
        url = params.get("url", "")
        method = params.get("method", "GET")
        
        try:
            if method.upper() == "GET":
                response = requests.get(url)
            elif method.upper() == "POST":
                response = requests.post(url, json=params.get("data", {}))
            else:
                response = requests.request(method, url)
                
            result = {{
                "status_code": response.status_code,
                "url": url,
                "method": method,
                "success": response.status_code < 400
            }}
        except Exception as e:
            result = {{"error": str(e), "success": False}}'''
            example_usage = f"web_request with URL and method parameters"
            
        # Code generation
        else:
            implementation = '''# Generic implementation
        input_data = params.get("input", "")
        
        # Process input based on description
        result = {{
            "processed": True,
            "input_length": len(str(input_data)),
            "description": "{description}"
        }}'''
            example_usage = f"execute with input parameter"
        
        return implementation, example_usage
    
    def _generate_reasoning(self, query: str, context: List[str]) -> str:
        """Generate reasoning for a query"""
        query_lower = query.lower()
        
        if "best practice" in query_lower or "how to" in query_lower:
            reasoning = f"For '{query}', I recommend: 1) Start with clear requirements, 2) Use modular design, 3) Add error handling, 4) Include tests, 5) Document your code."
        elif "compare" in query_lower or "difference" in query_lower:
            reasoning = f"Comparing options for '{query}': Consider factors like performance, maintainability, ease of use, and community support."
        elif "optimize" in query_lower or "improve" in query_lower:
            reasoning = f"To optimize '{query}': 1) Profile performance, 2) Identify bottlenecks, 3) Consider algorithmic improvements, 4) Test thoroughly."
        else:
            reasoning = f"Analyzing '{query}': This requires careful consideration of requirements, constraints, and available resources."
        
        return reasoning